---
title: 1.0 Vision   Ontology System
tags:
  - roadmap
  - vision
  - '1.0'
  - infrastructure
  - priority
---
# Ontology System

Optional type system for nodes. Standards-based, progressively strict.

## Core Design Decision

**`type` is a core Node field.**

```typescript
interface Node {
  id: string;
  title: string;
  content: string;
  tags: string[];
  links: Link[];
  properties: Record<string, unknown>;
  type?: string;  // Core field
  plugins?: Record<string, Record<string, unknown>>;
}
```

Type is structural, not metadata. It's the same level as `id` and `title`.

## Type Space

Roux has a unified type space. schema.org is one vocabulary within it:

| Type | Validator | Example |
|------|-----------|---------|
| `Recipe` | schema.org plugin | Cooking recipe |
| `Article` | schema.org plugin | Blog post |
| `Decision` | Decision Journal plugin | Architectural choice |
| `Task` | PM plugin | Work item |
| `roux:Custom` | None (user-defined) | Domain-specific |

Plugins register as validators for type patterns they understand.

## schema.org Integration

schema.org provides the default vocabulary for common types.

- Cache schema.org definitions locally (JSON-LD)
- Type inheritance built-in (Recipe → HowTo → CreativeWork → Thing)
- Validate against cached schema on write
- Warn on missing recommended fields, error on missing required

See: [[Plugin - Schema.org Validator]]

## Custom Types

Beyond schema.org:

- **Extend schema.org** — add properties to existing types
- **Standalone types** — domain-specific, no external schema
- **Relationship constraints** — edge X connects type A to type B

## Validation Pipeline

Hook into DocStore file watcher:

```
file change → watcher → parser → [type validation] → node emitted
```

Plugins register validators for type patterns:

```typescript
provides: {
  typeValidator: ['Recipe', 'Article', 'schema:*'],
}
```

When a node with matching type is parsed, validator runs. Results stored in plugin namespace.

## Optional AI Inference

- Detect probable type from unstructured content
- Suggest schema, extract properties automatically
- Human confirms or overrides

## Strictness Levels

Configurable per graph:

- **Permissive** (default): Types are advisory, no validation
- **Warn**: Log missing required fields, allow write
- **Strict**: Reject writes that violate schema

## Type Queries

First-class query support:

```typescript
graph.query({ type: 'Recipe' })
graph.query({ type: { startsWith: 'schema:' } })
graph.query({ type: { in: ['Task', 'Decision'] } })
```

## Enables

- Typed queries across the graph
- Relationship validation
- Domain-specific tooling
- Portable knowledge (schema.org is universal)
- [[1.0 Vision - Applications#CodeGraph]] — enforced structure for code nodes

## Implementation

The Ontology System is implemented via:

1. **Core `type` field** — added to Node interface
2. **Validator registration** — plugins declare what types they validate
3. **Validation pipeline** — hooks into DocStore parser
4. **schema.org plugin** — first validator, handles standard types

See: [[Plugin - Schema.org Validator]] for implementation details.
