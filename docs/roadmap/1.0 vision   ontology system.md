---
title: 1.0 Vision   Ontology System
tags:
  - roadmap
  - vision
  - '1.0'
  - infrastructure
  - priority
---
# Ontology System

Optional type system for nodes. Standards-based, progressively strict.

## Core Design Decisions

### 1. `type` is a core Node field

```typescript
interface Node {
  id: string;
  title: string;
  content: string;
  tags: string[];
  links: Link[];
  type?: string;  // Core field
  [context: string]: Record<string, unknown>;  // Context namespaces
}
```

See [[1.0 Vision - Node Schema]] for full schema.

### 2. schema.org is behind-the-scenes

schema.org provides the default type vocabulary, but it's not user-facing. Users don't interact with a "schema-org" namespace. They:
1. Declare `type: Recipe` on their node
2. Validator (powered by schema.org) validates and scaffolds
3. User data lives in their context namespace

### 3. Proactive metadata scaffolding

When type is detected, the system can add placeholder fields:

```yaml
# User creates
---
title: Bulgogi
type: Recipe
---

# System scaffolds
---
title: Bulgogi
type: Recipe
recipes:
  prepTime:     # placeholder
  cookTime:     # placeholder  
  ingredients: []
---
```

This prompts completeness without blocking creation.

## Type Space

Roux has a unified type space. Validators handle types they recognize:

| Type | Validator | Scaffolds |
|------|-----------|-----------|
| `Recipe` | schema.org | prepTime, cookTime, ingredients |
| `Article` | schema.org | author, datePublished |
| `Decision` | Decision Journal | context, options, outcome |
| `Task` | PM plugin | status, priority, assignee |
| `Custom` | None | No scaffolding |

Plugins register as validators for type patterns they understand.

## Validation Pipeline

Hook into DocStore file watcher:

```
file change → watcher → parser → [type validation + scaffolding] → node emitted
```

When a node with a recognized type is parsed:
1. Validator runs
2. Missing fields scaffolded as placeholders
3. Validation results cached internally
4. Node emitted with scaffolded fields

## Strictness Levels

Configurable per graph:

- **Permissive** (default): Types are advisory, scaffolding optional
- **Scaffold**: Auto-add placeholders for recognized types
- **Warn**: Log validation errors, allow writes
- **Strict**: Reject writes that violate required fields

## Type Queries

First-class query support:

```typescript
graph.query({ type: 'Recipe' })
graph.query({ type: { startsWith: 'schema:' } })
graph.query({ type: { in: ['Task', 'Decision'] } })
```

## Custom Types

Beyond schema.org:

- **Extend schema.org** — add properties to existing types
- **Standalone types** — domain-specific, custom validators
- **Relationship constraints** — edge X connects type A to type B

## Implementation

The Ontology System is implemented via:

1. **Core `type` field** — on Node interface
2. **Context-based namespacing** — user data in context namespace
3. **Validator registration** — plugins declare types they validate
4. **Validation pipeline** — hooks into DocStore parser
5. **Scaffolding** — proactive placeholder fields

See: [[Plugin - Schema.org Validator]] for primary implementation.
