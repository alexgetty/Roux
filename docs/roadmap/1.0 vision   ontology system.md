---
title: 1.0 Vision   Ontology System
tags:
  - roadmap
  - vision
  - '1.0'
  - infrastructure
  - priority
  - architecture
---
# Ontology System

Optional type system for nodes. Standards-based, progressively strict, extensible via providers.

## Core Architecture

### SchemaProvider Abstraction

Schema handling follows the same provider pattern as storage and embeddings:

```typescript
interface SchemaProvider {
  id: string;
  
  // Discovery
  listTypes(): TypeDefinition[];
  getType(name: string): TypeDefinition | null;
  
  // Intelligence
  inferType(content: string): TypeMatch[];
  extractProperties(content: string, type: string): Record<string, unknown>;
  
  // Validation
  validate(node: Node): ValidationResult;
  
  // Scaffolding
  scaffold(type: string): Partial<Node>;
}
```

### Composition Model

Multiple SchemaProviders coexist. GraphCore aggregates them:

```
┌─────────────────────────────────────────────────┐
│                   GraphCore                      │
│                                                  │
│   ┌──────────────┐  ┌──────────────┐            │
│   │ CoreSchema   │  │ PluginSchema │  ...       │
│   │   Provider   │  │   Provider   │            │
│   └──────┬───────┘  └──────┬───────┘            │
│          │                 │                     │
│          ▼                 ▼                     │
│   ┌─────────────────────────────────┐           │
│   │    Composed Schema Interface     │           │
│   │  lookup · infer · validate · ... │           │
│   └─────────────────────────────────┘           │
└─────────────────────────────────────────────────┘
```

- **Core provider** ships with Roux — wraps schema.org + Roux-specific types
- **Plugin providers** — domain-specific types, same interface
- **Priority resolution** — first provider claiming a type wins (configurable order)

Plugins don't extend the core provider. They implement the same interface, register separately. Clean decoupling, testable in isolation.

### Why schema.org

schema.org is the lingua franca of structured data:
- Used by Google, Microsoft, Apple, the entire SEO industry
- Every frontier LLM has it in training data — zero-shot understanding
- Anything structured against it becomes machine-readable by *everything*

But schema.org is a *subset*, not the whole system. The SchemaProvider abstraction allows extending beyond it.

## Schema as a Service

Schema intelligence is exposed as an API surface for external consumers (browser extensions, mobile apps, CLI tools):

| Capability | Description |
|------------|-------------|
| `schema.lookup(type)` | "What properties does Recipe have?" |
| `schema.infer(content)` | "This content looks like a Recipe, 89% confidence" |
| `schema.extract(content, type)` | "Pull these fields from this text" |
| `schema.validate(node)` | "Is this node complete for its type?" |
| `schema.scaffold(type)` | "Give me placeholder fields for Recipe" |

Apps bring raw content. Roux brings the intelligence about *what* that content is and *how* to structure it.

**Example flow — browser extension:**

```
[Browser Extension]              [Roux API]
        |                            |
        |-- "What type is this?" --->|
        |<-- "Recipe. Extract these" |
        |                            |
        |-- "Here's the node" ------>|
        |<-- "Validated, stored" ----|
```

## Core Design Decisions

### 1. `type` is a core Node field, `tags` is not

```typescript
interface Node {
  id: string;         // immutable, auto-generated
  title: string;      // user-controlled
  content: string;
  links: Link[];
  type?: string;      // Core field — schema reference
  
  [context: string]: Record<string, unknown>;
}
```

**Why `type` is core:**
- Structural meaning — "this node IS a Recipe" affects validation, scaffolding, queries
- Schema integration — SchemaProvider needs to know the type to validate
- First-class query support — `graph.query({ type: 'Recipe' })`

**Why `tags` is NOT core:**
- Redundant with graph links — `[[Korean Cuisine]]` is more useful than `tags: [korean]`
- No structural meaning — tags are arbitrary strings, no validation
- Plugin/app concern — apps that want tags use context namespaces

See [[roadmap/Tag Utility]] for the deferred tag system design.

### 2. schema.org is behind-the-scenes

schema.org powers the core provider, but it's not user-facing. Users don't interact with a "schema-org" namespace. They:
1. Declare `type: Recipe` on their node
2. SchemaProvider validates and scaffolds
3. User data lives in their context namespace

### 3. Proactive metadata scaffolding

When type is detected, the system can add placeholder fields:

```yaml
# User creates
---
id: n7x2k9m4
title: Bulgogi
type: Recipe
---

# System scaffolds
---
id: n7x2k9m4
title: Bulgogi
type: Recipe
recipes:
  prepTime:     # placeholder
  cookTime:     # placeholder  
  ingredients: []
---
```

This prompts completeness without blocking creation.

## Type Space

Unified type space. Providers handle types they recognize:

| Type | Provider | Scaffolds |
|------|----------|-----------|
| `Recipe` | Core (schema.org) | prepTime, cookTime, ingredients |
| `Article` | Core (schema.org) | author, datePublished |
| `Decision` | Decision Journal plugin | context, options, outcome |
| `Task` | PM plugin | status, priority, assignee |
| `WineNote` | Sommelier plugin | vintage, varietal, rating |
| `Custom` | None | No scaffolding |

## Strictness Levels

Configurable per graph:

- **Permissive** (default): Types are advisory, scaffolding optional
- **Scaffold**: Auto-add placeholders for recognized types
- **Warn**: Log validation errors, allow writes
- **Strict**: Reject writes that violate required fields

## Type Queries

First-class query support:

```typescript
graph.query({ type: 'Recipe' })
graph.query({ type: { startsWith: 'schema:' } })
graph.query({ type: { in: ['Task', 'Decision'] } })
```

## Custom Types

Beyond schema.org:

- **Extend schema.org** — inherit base type, add properties
- **Standalone types** — domain-specific, custom provider
- **Type inheritance** — Article → BlogPosting inherits properties

## Implementation Phases

1. **SchemaProvider interface** — define the abstraction in `types/`
2. **Core provider** — wrap schema.org, ship with Roux
3. **GraphCore integration** — provider registration, composition
4. **MCP tools** — expose schema services
5. **Validation pipeline** — hook into DocStore parser
6. **Plugin support** — allow plugins to register providers

## Open Questions

- Naming: "CoreSchemaProvider" is placeholder — needs better name
- Conflict resolution: What happens when two providers claim the same type?
- Inheritance: How does type extension work across providers?

## Related

- [[1.0 Vision - Node Schema]] — context-based namespacing
- [[decisions/Node Identity]] — core fields definition
- [[roadmap/Tag Utility]] — why tags aren't core
- [[Plugin - Schema.org Validator]] — original plugin concept (now subset of this system)
- [[Plugin System]] — plugin registration infrastructure
