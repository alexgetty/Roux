---
id: FzwyKGyoUaUE
title: 1.0 Vision   Node Schema
tags:
  - roadmap
  - vision
  - '1.0'
  - infrastructure
  - schema
---
# Node Schema

The fundamental data structure. Every piece of knowledge is a node.

## Core Design

**Core fields are reserved. Everything else is namespaced by context.**

```typescript
interface Node {
  // Core fields (reserved, top-level only)
  id: string;         // immutable, auto-generated
  title: string;      // user-controlled, used for wikilink resolution
  content: string;
  links: Link[];
  type?: string;      // schema reference
  
  // Context namespaces (everything else)
  [context: string]: Record<string, unknown>;
}
```

No `properties` bucket. No `plugins` bucket. No `tags` at core level. Just core fields + namespaced contexts.

### Why No Core Tags

Tags are redundant with graph linking. See [[roadmap/Tag Utility]] for rationale.

- **Categorization**: Use `type` field or link to hub notes
- **Filtering**: Query by type or link targets
- **Clustering**: Graph traversal

Plugins/apps that want tags can use them in their context namespace:

```yaml
my-app:
  tags: [recipe, korean]
```

## Identity Model

See [[decisions/Node Identity]] for full decision record.

| Concern | Field | Controlled By | Mutable? |
|---------|-------|---------------|----------|
| Identity | `id` | Roux (auto-generated) | Never |
| Reference | `title` | User | Yes |
| Location | (path) | User (filesystem) | Yes |

Wikilinks use titles. System uses IDs. Paths are storage details.

## Context Model

A **context** is a coherent subgraph - nodes that belong together conceptually. Every non-core field lives in a context namespace.

| Context Type | Example Namespace | Source |
|--------------|-------------------|--------|
| User data | `recipes`, `research` | Configured per scope |
| Plugin | `pm`, `github`, `time` | Plugin ID |
| Federated | `team-docs`, `external` | Merged from other graphs |

### Why Contexts, Not Workspaces

"Workspace" is filesystem thinking. "Context" is graph thinking.

- Contexts federate into larger graphs
- Multiple contexts contribute to the same node
- Contexts can be nested, merged, filtered
- Aligns with "context injection", "context curation"

## Frontmatter Format

```yaml
---
# Core fields (reserved)
id: n7x2k9m4
title: Bulgogi
type: Recipe

# Context: user data (namespace = configured context name)
recipes:
  author: Alex
  rating: 5
  source: Maangchi

# Context: plugin data (namespace = plugin ID)
pm:
  status: done
  completedAt: 2025-01-30

# Context: federated data (namespace = source context)
team-notes:
  discussed: 2025-01-15
  feedback: "needs more garlic"
---
```

## Context Naming

Context name is configurable per Roux scope:

```typescript
// roux.config.ts
{
  // Explicit name
  context: 'recipes',
  
  // OR derive from directory
  context: 'directory',
  
  // OR custom logic
  context: (path) => path.split('/')[2],
}
```

Plugins always use their plugin ID as namespace. No configuration needed.

## Reserved Names

Core field names cannot be used as context namespaces:

- `id`
- `title`
- `content`
- `links`
- `type`

Attempting to use a reserved name as namespace throws an error.

## Benefits

1. **No collisions** - `recipes.status` and `pm.status` coexist
2. **Clear provenance** - you see what context created each field
3. **Easy cleanup** - remove a context, delete its namespace
4. **Portable** - namespace travels with the node when federated
5. **Self-documenting** - frontmatter shows data lineage
6. **Uniform API** - no special cases for "user" vs "plugin" data

## Query Support

Namespaced queries:

```typescript
graph.query({ where: { 'pm.status': 'open' } })
graph.query({ where: { 'recipes.rating': { gt: 4 } } })
graph.query({ contexts: ['pm', 'recipes'] })  // nodes touched by these contexts
```

## Related

- [[decisions/Node Identity]] — ID/title/path separation
- [[roadmap/Tag Utility]] — why tags aren't core
- [[1.0 Vision - Ontology System]] — type system
