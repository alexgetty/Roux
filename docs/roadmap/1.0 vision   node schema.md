---
title: 1.0 Vision   Node Schema
tags:
  - roadmap
  - vision
  - '1.0'
  - infrastructure
  - schema
---
# Node Schema

The fundamental data structure. Every piece of knowledge is a node.

## Core Design

**Core fields are reserved. Everything else is namespaced by context.**

```typescript
interface Node {
  // Core fields (reserved, top-level only)
  id: string;
  title: string;
  content: string;
  tags: string[];
  links: Link[];
  type?: string;
  
  // Context namespaces (everything else)
  [context: string]: Record<string, unknown>;
}
```

No `properties` bucket. No `plugins` bucket. Just core fields + namespaced contexts.

## Context Model

A **context** is a coherent subgraph - nodes that belong together conceptually. Every non-core field lives in a context namespace.

| Context Type | Example Namespace | Source |
|--------------|-------------------|--------|
| User data | `recipes`, `research` | Configured per scope |
| Plugin | `pm`, `github`, `time` | Plugin ID |
| Federated | `team-docs`, `external` | Merged from other graphs |

### Why Contexts, Not Workspaces

"Workspace" is filesystem thinking. "Context" is graph thinking.

- Contexts federate into larger graphs
- Multiple contexts contribute to the same node
- Contexts can be nested, merged, filtered
- Aligns with "context injection", "context curation"

## Frontmatter Format

```yaml
---
# Core fields (reserved)
title: Bulgogi
type: Recipe
tags: [korean, beef]

# Context: user data (namespace = configured context name)
recipes:
  author: Alex
  rating: 5
  source: Maangchi

# Context: plugin data (namespace = plugin ID)
pm:
  status: done
  completedAt: 2025-01-30

# Context: federated data (namespace = source context)
team-notes:
  discussed: 2025-01-15
  feedback: "needs more garlic"
---
```

## Context Naming

Context name is configurable per Roux scope:

```typescript
// roux.config.ts
{
  // Explicit name
  context: 'recipes',
  
  // OR derive from directory
  context: 'directory',
  
  // OR custom logic
  context: (path) => path.split('/')[2],
}
```

Plugins always use their plugin ID as namespace. No configuration needed.

## Reserved Names

Core field names cannot be used as context namespaces:

- `id`
- `title`
- `content`
- `tags`
- `links`
- `type`

Attempting to use a reserved name as namespace throws an error.

## Benefits

1. **No collisions** - `recipes.status` and `pm.status` coexist
2. **Clear provenance** - you see what context created each field
3. **Easy cleanup** - remove a context, delete its namespace
4. **Portable** - namespace travels with the node when federated
5. **Self-documenting** - frontmatter shows data lineage
6. **Uniform API** - no special cases for "user" vs "plugin" data

## Query Support

Namespaced queries:

```typescript
graph.query({ where: { 'pm.status': 'open' } })
graph.query({ where: { 'recipes.rating': { gt: 4 } } })
graph.query({ contexts: ['pm', 'recipes'] })  // nodes touched by these contexts
```

## Migration from properties/plugins

Old format:
```yaml
properties:
  author: Alex
plugins:
  pm:
    status: done
```

New format:
```yaml
recipes:  # or whatever context name
  author: Alex
pm:
  status: done
```

Migration: move `properties.*` into configured context namespace, flatten `plugins.*` to top level.
